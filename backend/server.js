// backend/server.js

const express = require('express');
const OpenAI = require('openai');
const cors = require('cors');
const nodemailer = require('nodemailer');
const { TwitterApi } = require('twitter-api-v2');
const axios = require('axios');
const path = require('path');
require('dotenv').config(); // Loads .env file

const app = express();
const port = process.env.PORT || 5000;

// --- Middleware ---
app.use(cors());
app.use(express.json());

// --- 1. AI "BRAIN" CONFIG (OpenAI) ---
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

// --- 2. EMAIL "HAND" CONFIG (Nodemailer + GMAIL) ---
const transporter = nodemailer.createTransport({
  service: 'gmail',
  auth: {
    user: process.env.EMAIL_USER,
    pass: process.env.EMAIL_PASS,
  },
});

async function sendEmailAlert(message, recipientEmail) {
  try {
    const info = await transporter.sendMail({
      from: `"Health Sarthi" <${process.env.EMAIL_USER}>`,
      to: recipientEmail,
      subject: '[URGENT] AI-Detected Health Surge Alert',
      html: `
        <h3>Automated Alert from Health Sarthi</h3> 
        <p>This is a high-priority alert generated by the autonomous AI agent.</p>
        <hr>
        <strong>MESSAGE:</strong>
        <p style='font-size: 1.2em; color: red;'>${message}</p>
        <hr>
      `,
    });
    return { success: true, destination: recipientEmail };
  } catch (error) {
    console.error('Error sending email:', error);
    return { success: false, error: error.message };
  }
}

// --- 3. TWEET "HAND" CONFIG (Twitter) ---
const twitterClient = new TwitterApi({
  appKey: process.env.TWITTER_API_KEY,
  appSecret: process.env.TWITTER_API_SECRET,
  accessToken: process.env.TWITTER_ACCESS_TOKEN,
  accessSecret: process.env.TWITTER_ACCESS_TOKEN_SECRET,
});
const rwClient = twitterClient.readWrite;

async function postTweetAdvisory(message) {
  try {
    const { data: createdTweet } = await rwClient.v2.tweet(message);
    return { success: true, tweetId: createdTweet.id };
  } catch (error) {
    console.error('Error posting tweet:', error);
    return { success: false, error: error.message };
  }
}

// --- 4. AQI "SENSE" MODULE ---
async function getLiveAQI(cityName) {
  try {
    const token = process.env.AQI_API_TOKEN;
    const station = encodeURIComponent(cityName); 
    const url = `https://api.waqi.info/feed/${station}/?token=${token}`;
    const response = await axios.get(url);

    if (response.data.status === "ok") {
      return response.data.data.aqi;
    } else {
      console.error(`AQI API returned an error for ${station}:`, response.data.data);
      return null;
    }
  } catch (error) {
    console.error(`Error fetching live AQI for ${cityName}:`, error.message);
    return null;
  }
}

// --- 5. SOCIAL "SENSE" MODULE ---
// --- 5. SOCIAL "SENSE" MODULE (UPDATED WITH 429 HANDLING) ---
async function getSocialMediaChatter(cityName) {
  try {
    const query = `(cough OR fever OR hospital OR #oxygen) (${cityName} OR #${cityName}) -is:retweet`;
    const startTime = new Date(Date.now() - 10 * 60 * 1000).toISOString();

    const searchResult = await rwClient.v2.search(query, {
      'start_time': startTime,
      'tweet.fields': 'created_at,text',
      'max_results': 10 
    });

    const tweetCount = searchResult.meta.result_count;
    const tweets = searchResult.data || []; 

    console.log(`Live social chatter for ${cityName}: ${tweetCount} new tweets.`);
    return { tweetCount, tweets }; 

  } catch (error) {
    // --- NEW: Check specifically for Rate Limit Error ---
    if (error.code === 429) {
      console.warn(`Twitter search rate limit hit (429). Returning 0 chatter.`);
      return { tweetCount: 0, tweets: [], error: 'Search Rate Limited (429)' }; // Return 0 but indicate the limit was hit
    } else {
      // Log other errors but still return 0 to prevent crashing
      console.error(`Error fetching social chatter:`, error);
      return { tweetCount: 0, tweets: [], error: error.message }; 
    }
    // --- End New Error Handling ---
  }
}

// --- MOCK INVENTORY ---
const MOCK_INVENTORY = {
  "Salbutamol Inhalers": 50, "N95 Masks": 500, "Water Purification Tablets": 1000
};


// --- MAIN API ENDPOINT (SENSE -> THINK (MOCKED) -> ACT) ---
app.post('/api/get-plan', async (req, res) => {
  try {
    const { crisisData: contextualData, recipientEmail } = req.body;
    console.log("Received contextual data:", contextualData);

    // 1. SENSE: Fetch Live Data
    const cityName = contextualData.selectedCity;
    const [liveAqi, chatterData] = await Promise.all([
        getLiveAQI(cityName),
        getSocialMediaChatter(cityName)
    ]);

    if (liveAqi === null && !contextualData.is_flood_alert) {
      throw new Error(`Could not fetch live AQI data for ${cityName}.`);
    }

    const chatterCount = chatterData.tweetCount;
    const chatterTweets = chatterData.tweets; 
    const currentAqi = liveAqi || 0; 

    const finalCrisisData = {
        live_aqi: currentAqi,
        city: cityName,
        social_media_chatter_count: chatterCount,
        is_festival: contextualData.is_festival,
        is_flood_alert: contextualData.is_flood_alert
    };

    // 2. THINK (MOCKED DECISION LOGIC)
    let plan; 
    const city = finalCrisisData.city;
    const crisisLevel = currentAqi + (chatterCount * 5); 

    if (finalCrisisData.is_flood_alert) {
      plan = {
        "analysis": `MOCK (LIVE): FLOOD ALERT! Active flood warning in ${city}. High risk of waterborne diseases.`,
        "actions": {
          "staffing_alert": { "send": true, "message": `URGENT (${city}): FLOOD ALERT. Prepare for trauma/waterborne cases.` },
          "supply_order": { "order": true, "item": "Water Purification Tablets", "quantity": 500, "reason": `Flood alert in ${city}.` },
          "public_advisory": { "post": true, "message": `PUBLIC SAFETY ALERT (${city}): FLOOD WARNING. Avoid floodwaters. Boil drinking water.` }
        }
      };
    } 
    else if (crisisLevel > 150) { 
      plan = {
        "analysis": `MOCK (LIVE): WARNING. AQI in ${city} is ${currentAqi} & chatter is ${chatterCount}. Unhealthy conditions detected.`,
        "actions": {
          "staffing_alert": { "send": true, "message": `URGENT (${city}): Live AQI is ${currentAqi} & ${chatterCount} illness reports. Prepare for respiratory surge.` },
          "supply_order": { "order": true, "item": "Salbutamol Inhalers", "quantity": 200, "reason": `Stock low, AQI=${currentAqi}, chatter=${chatterCount}` },
          "public_advisory": { "post": true, "message": `PUBLIC HEALTH ADVISORY (${city}): AQI is ${currentAqi} (Unhealthy). People with lung conditions should reduce exertion.` }
        }
      };
    } else { // All Clear
      plan = {
        "analysis": `MOCK (LIVE): OK. AQI in ${city} is ${currentAqi} & chatter is ${chatterCount}. All clear.`,
        "actions": {
          "staffing_alert": { "send": false, "message": "" },
          "supply_order": { "order": false, "item": "", "quantity": 0, "reason": "" },
          "public_advisory": { "post": false, "message": "" }
        }
      };
    }

    await new Promise(resolve => setTimeout(resolve, 1500)); // Simulate thinking time

    // 3. ACT: Execute Plan
    let actionsLog = [];
    if (plan.actions.staffing_alert.send && recipientEmail) {
      const emailResult = await sendEmailAlert(plan.actions.staffing_alert.message, recipientEmail);
      actionsLog.push({ type: 'email', ...emailResult });
    }
    // Keep this mocked for deployment stability
if (plan.actions.public_advisory.post) {
  // NOTE: Tweet sending is MOCKED to avoid permanent Twitter API rate limits (Code 429).
  actionsLog.push({ 
    type: 'tweet', 
    success: true, // Mock success
    tweetId: 'MOCK-ID-SUCCESS-429', 
    error: 'N/A' 
  }); 
  // const tweetResult = await postTweetAdvisory(plan.actions.public_advisory.message); // Real call remains commented out
  // actionsLog.push({ type: 'tweet', ...tweetResult });
}

    res.json({ plan, actionsLog, liveAqi: currentAqi, chatterCount: chatterCount, chatterTweets: chatterTweets });

  } catch (error) {
    console.error("Error in /api/get-plan:", error);
    res.status(500).json({ error: error.message || "Failed to generate plan. Check backend console." });
  }
});

// --- COMBINED DEPLOYMENT: API Routes MUST come before these lines ---

// 4. Serve the Frontend Files (Vanilla JS)
// 4. Serve the Frontend Files (Vanilla JS)
app.use(express.static(path.join(__dirname, '../frontend'))); 

// 5. CATCH-ALL Route (Sends index.html for all other requests)
// The simple '/' route handles the root, and the static middleware handles the files.
app.get('/', (req, res) => {
    res.sendFile(path.join(__dirname, '../frontend/index.html'));
});


app.listen(port, () => {
  console.log(`Backend server listening at http://localhost:${port}`);
});